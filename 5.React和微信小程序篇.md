# React和微信小程序篇

## 小程序

## 1说说你对微信小程序的理解？优缺点？

小程序是一种不需要下载安装就能使用的一种应用，用户扫一扫或者搜一下就可以打开。

微信小程序相比`H5`有几点不同：

- 运⾏环境：⼩程序是基于浏览器内核重构的内置解析器
- 系统权限：⼩程序能获得更多的系统权限，如⽹络通信状态、数据缓存能⼒等
- 渲染机制：⼩程序的逻辑层和渲染层是分开的

小程序可以视为只能用微信打开和浏览的`H5`，小程序和网页的技术模型是一样的，用到的 `JavaScript` 语言和 `CSS` 样式也是一样的，只是网页的 `HTML` 标签被稍微修改成了 `WXML` 标签。因此可以说，小程序页面本质上就是网页



## 2小程序有什么优缺点？

优点：

- 随搜随用，用完即走
- 流量大，易接受
- 安全
- 开发门槛低
- 降低兼容性限制

缺点：

- 用户留存比较低
- 体积限制：微信小程序只有2M的大小，但是可以通过分包机制进行扩展，最大到20M
- 受到微信控制



## 3、说说微信小程序的生命周期函数有哪些？

小程序中，生命周期主要分成了三部分：

- 应用的生命周期
- 页面的生命周期
- 组件的生命周期

**应用生命周期有：**

| onLaunch | 小程序初始化完成时触发，全局只触发一次 |
| -------- | -------------------------------------- |
| onShow   | 启动，或从后台进入前台显示时触发       |
| onHide   | 从前台进入后台时触发                   |

**页面的生命周期**

| 生命周期   | 说明                   | 作用                           |
| ---------- | ---------------------- | ------------------------------ |
| **onLoad** | 页面加载时执行         | 发送请求获取数据               |
| **onShow** | 页面显示出来的时候执行 | 请求数据                       |
| onReady    | 页面初次渲染完成时执行 | 获取页面元素（少用）           |
| onHide     | 页面隐藏时执行         | 终止任务，如定时器或者播放音乐 |
| onUnload   | 页面卸载时执行         | 终止任务                       |

**组件的生命周期**

| 生命周期 | 说明             |
| -------- | ---------------- |
| created  | 页面加载         |
| attached | 页面显示         |
| ready    | 页面初次渲染完成 |
| moved    | 页面隐藏         |
| detached | 页面卸载         |



## 、说说微信小程序中路由跳转的方式有哪些？区别？

小程序中路由跳转的方式有：

- navigateTo 保留当前页面，跳转到应用内的某个页面，使用 wx.navigateBack 可以返回到原页
- redirectTo 是重定向，关闭当前页面，跳转到应用内的某个页面
- switchTab 跳转到 tabBar 页面
- navigateBack 返回上一页面
- reLanch 关闭所有页面，打开到应用内的某个页面

## 5、说说提高微信小程序的应用速度的手段有哪些？

可以从两个方面做，一个是提高加载速度，一个是提高渲染速度。

#### 加载

最直接的方法是控制小程序包的大小，比如：

- 代码包的**体积压缩**。可以通过勾选开发者工具中“**上传代码时，压缩代码**”选项
- 及时**清理无用的代码和资源文件**
- **减少资源包中的图片等资源的数量和大小**（除了小图标，其他图片资源从网络下载）
- 再就是采取分包加载的操作，将用户访问率高的页面放在主包里，将访问率低的页面放入子包里，按需加载

#### 渲染

关于微信小程序首屏渲染优化的手段如下：

- 请求可以在页面onLoad就加载，不需要等页面ready后再异步请求数据
- 尽量减少不必要的https请求，可使**用 getStorageSync() 及 setStorageSync() 方法将数据存储在本地**
- 可以在前置页面将一些有用的字段带到当前页，进行首次渲染（列表页的某些数据--> 详情页），没有数据的模块可以进行骨架屏的占位
- 不要过于频繁调用setData，应考虑将多次setData合并成一次setData调用

## 

#### 总结

**小程序启动加载性能**：

- 控制代码包的大小
- 分包加载
- 首屏体验（预请求，利用缓存，避免白屏，及时反馈

**小程序渲染性能**：

- 避免不当的使用setData
- 使用自定义组件

### 

## 6、 说说微信小程序的登录流程？

- 通过 wx.login() 获取到用户的code判断用户是否授权读取用户信息，调用wx.getUserInfo 读取用户数据
- 由于小程序后台授权域名无法授权微信的域名，所以需要自身后端调用微信服务器获取用户信息
- 通过 wx.request() 方法请求业务方服务器，后端把 appid , appsecret 和 code 一起发送到微信服务器。 appid 和 appsecret 都是微信提供的，可以在管理员后台找到
- 微信服务器返回了 openid 及本次登录的会话密钥 session_key
- 后端从数据库中查找 openid ，如果没有查到记录，说明该用户没有注册，如果有记录，则继续往下走
- session_key 是对用户数据进行加密签名的密钥。为了自身应用安全，session_key 不应该在网络上传输
- 然后生成 session并返回给小程序
- 小程序把 session 存到 storage 里面
- 下次请求时，先从 storage 里面读取，然后带给服务端
- 服务端对比 session 对应的记录，然后校验有效期





## 7、说说微信小程序的发布流程？

- 代码管理服务器上新建分支
- 开发测试新需求
- 测试完成后，将本地分支合并到 master 分支
- 拉取 master 分支最新代码，执行 build 命令生成小程序可执行文件
- 开发者工具点击“上传”
- 提审
- 发布



## 8、说说微信小程序的支付流程？

具体的做法：

- 打开某小程序，点击直接下单
- **wx.login**获取用户临时**登录凭证code**，发送到后端服务器换取**openId**
- 在下单时，小程序需要**将购买的商品Id，商品数量，以及用户的openId传送到服务器**
- 服务器在接收到商品Id、商品数量、openId后，生成服务期订单数据，同时经过一定的签名算法，向微信支付发送请求，获取预付单信息(prepay_id)，同时将获取的数据再次进行相应规则的签名，向小程序端响应必要的信息
- 小程序端在获取对应的参数后，调用wx.requestPayment()发起微信支付，唤醒支付工作台，进行支付
- 接下来的一些列操作都是由用户来操作的包括了微信支付密码，指纹等验证，确认支付之后执行鉴权调起支付
- 鉴权调起支付：在微信后台进行鉴权，微信后台直接返回给前端支付的结果，前端收到返回数据后对支付结果进行展示
- 推送支付结果：微信后台在给前端返回支付的结果后，也会向后台也返回一个支付结果，后台通过这个支付结果来更新订单的状态

### 

## React

## 1、说说对 React 的理解？有哪些特性？

`React` 特性有很多，如：

- 支持JSX 语法
- 单向的数据绑定
- 虚拟 DOM
- 声明式编程
- 支持组件



## 2、说说 Real DOM（真实DOM） 和 Virtual DOM（虚拟DOM） 的区别？优缺点？

Real DOM，就是真实 `DOM`，意思是文档对象模型。

而`Virtual Dom`，本质上是以 `JavaScript` 对象来描述 `DOM` 。

创建虚拟 `DOM` 目的就是为了更好将虚拟的节点渲染到页面视图中，虚拟 `DOM` 对象的节点与真实 `DOM` 的属性一一对应。

他们的区别是：

- 虚拟 DOM 不会进行排版与重绘操作，而真实 DOM 会频繁重排与重绘

传统的原生 `api` 或 `jQuery` 去操作 `DOM` 时，浏览器会从构建 `DOM` 树开始从头到尾执行一遍流程

当你在一次操作时，需要更新 10 个 `DOM` 节点，浏览器没这么智能，收到第一个更新 `DOM` 请求后，并不知道后续还有 9 次更新操作，因此会马上执行流程，最终执行 10 次流程

而通过 `VNode`，同样更新 10 个 `DOM` 节点，虚拟 `DOM` 不会立即操作 `DOM`，而是将这 10 次更新的 `diff` 内容保存到本地的一个 `js` 对象中，最终将这个 `js` 对象一次性 `attach` 到 `DOM` 树上，避免大量的无谓计算



## 3、说说 React 生命周期有哪些不同阶段？每个阶段对应的方法是？

#### 1、constructor

实例过程中自动调用的方法，在方法内部通过`super`关键字获取来自父组件的`props`

在这个方法中，可以初始化`state`状态或者在`this`上挂载方法

#### 2、getDerivedStateFromProps

在每次`render`方法前调用，第一个参数为即将更新的`props`，第二个参数为上一个状态的`state`，可以比较`props` 和 `state`来加一些限制条件，防止无用的state更新

#### 3、render

类组件必须实现的方法，用于渲染`DOM`结构，可以访问组件`state`与`prop`属性

需要注意的是： 不要在 `render` 里面调用 `setState`, 否则会触发死循环导致内存崩溃

#### 4、componentDidMount

组件挂载到真实`DOM`节点后执行，其在`render`方法之后执行

此方法多用于执行一些数据获取，事件监听等操作

#### 5、更新阶段

该阶段的函数主要为如下方法：

- shouldComponentUpdate
- componentDidUpdate

#### shouldComponentUpdate

通过返回true或者false来告诉组件是否更新，也不能调用`setState`

#### componentDidUpdate

组件更新结束后触发，可以获取更新之后的DOM，修改`DOM`样式等

#### 6、卸载阶段

#### componentWillUnmount

在组件卸载前，清理一些注册监听事件，或者取消订阅的网络请求等



## 4、state 和 props 有什么区别？

相同点：

- 都是 JavaScript 对象
- 都是用于保存信息
- props 和 state 都能触发渲染更新

区别：

- props 是外部传递给组件的，而 state 是在组件内被组件自己管理的，一般在 constructor 中初始化
- props 在组件内部是不可修改的，但 state 在组件内部可以进行修改

## 

## 5、super() 和 super(props) 有什么区别？

在 `React` 中，类组件基于 `ES6`，所以在 `constructor` 中必须使用 `super`

在调用 `super` 过程，无论是否传入 `props`，`React` 内部都会将 `porps` 赋值给组件实例 `porps` 属性中

如果只调用了 `super()`，那么 `this.props` 在 `super()` 和构造函数结束之间仍是 `undefined`





## 6、 React中的setState是同步的还是异步的？

- 在组件生命周期或React合成事件中，setState是异步
- 在setTimeout或者原生dom事件中，setState是同步

### 

## 7、说说React的事件机制？

`React`基于浏览器的事件机制自身实现了一套事件机制，包括事件注册、事件的合成、事件冒泡、事件派发等

在`React`中这套事件机制被称之为合成事件

- React 上注册的事件最终会绑定在document这个 DOM 上，而不是 React 组件对应的 DOM(减少内存开销就是因为所有的事件都绑定在 document 上，其他节点没有绑定事件)
- React 自身实现了一套事件冒泡机制，所以这也就是为什么我们 event.stopPropagation()无效的原因。
- React 通过队列的形式，从触发的组件向父组件回溯，然后调用他们 JSX 中定义的 callback
- React 有一套自己的合成事件 SyntheticEvent



## 8、React事件绑定的方式有哪些？区别？



`React`事件机制总结如下：

- React 上注册的事件最终会绑定在document这个 DOM 上，而不是 React 组件对应的 DOM(减少内存开销就是因为所有的事件都绑定在 document 上，其他节点没有绑定事件)
- React 自身实现了一套事件冒泡机制，所以这也就是为什么我们 event.stopPropagation()无效的原因。
- React 通过队列的形式，从触发的组件向父组件回溯，然后调用他们 JSX 中定义的 callback
- React 有一套自己的合成事件



## 9、React构建组件的方式有哪些？区别？

主要有类组件和函数式组件。

* 类组件通过定义一个类，继承React.Component，然后在类中添加render方法，返回渲染的内容。props在this上。state在constructor构造函数中初始化。

* 还有一个是函数式组件，函数式组件是在函数中返回显示的内容。函数的参数是props。函数式组件是无状态组件，也没有声明周期函数。但是可以通过useState 和useEffect 钩子（hook）来实现组件内部状态和生命周期。



## 10、 React中组件之间如何通信？

组件通信主要包括这么几种情况。

* 父传子，父组件通过prop把数据传给子组件
* 子传父。任然可以通过prop来实现。也就是父组件通过prop传给子组件一个函数。在子组件中调用函数，传入参数，父组件就可以收到子组件的数据了。
* 兄弟组件通信的话可以通共同的父组件来实现。然后还可以通过Context来实现跨组件通信。
* 最后可以借助于第三方的状态管理库来实现，比如redux、saga、resso等。



## 11、React中的key有什么作用？

跟`Vue`一样，`React` 也存在 `Diff`算法，而元素`key`属性的作用是用于判断元素是新创建的还是被移动的元素，从而减少不必要的元素渲染

因此`key`的值需要为每一个元素赋予一个确定的标识。





## 12. 说说对React refs 的理解？应用场景？

通常在需要获取某个组件或者DOM的时候，会用到ref。

用法是使用 React.createRef() 开创建一个ref实例，然后把他添加到组件或者元素的ref属性上。这样就可以通过这个ref实例来获取到组件或者元素了。



## 13、说说对React中类组件和函数组件的理解？有什么区别？

类组件是定义一个class，继承React.Component。类组件必须要定义一个render函数。在函数中返回要显示的组件内容。类组件在构造函数中初始化state。由于继承子React.Component，所以在this上可以直接获得props属性。另外类组件还有一些列的生命周期函数。（**参见上面第三题**）。

二函数式组件是通过定义一个函数来实现的。函数式组件会更灵活，props可以从函数的参数中获取。另外函数式组件是无状态组件，也没有所谓的生命周期。但函数式组件可以通过hook来实现组件的状态和类似生命周期的功能。在函数式组件中，可以使用自定义hook，提高了代码的复用性。



## 14、说说对受控组件和非受控组件的理解？应用场景？

受控组件，简单来讲，就是受我们控制的组件，可以通过value属性获取和修改组件的值。比如常见的输入框组件就是受控组件。

非受控组件，简单来讲，就是不受我们控制的组件。比如 当input的type等于file时，用来做文件上传的时候就是非受控组件。非受控组件可以通过ref来获取组件以及组件的的值。



## 15、说说对React Hooks的理解？解决了什么问题？

React的hook和Vue3的Composition组合式API很像。

Hooks可以让函数组件拥有了类组件的特性，例如组件内的状态、生命周期

最常见的`hooks`有如下：

- useState
- useEffect

另外我们可以自定义hook。

我们可以把组件内需要复用的逻辑代码抽离出来，定义成hook，然后在组件内引入，从而提高了代码的复用性。

## 16、说说react中引入css的方式有哪几种？区别？

* 可以定义class类名，但是要添加到组件的className属性上
* 第二种是行内样式，把样式定义为对象，添加到style属性上。也可以把样式定义到一个单独的js文件中。
* 引入 .module.css 文件，这个是`webpack`的方案，需要配置`webpack`中的`modules:true`
* 还有一种是CSS-in-JS,他的`CSS`由 `JavaScript`生成

