## 1、HTTP与HTTPS的区别

- HTTP的URL由`http://`起始且默认使用端口80，而HTTPS的URL由`https://`起始且默认使用端口443
- HTTP是超文本传输协议，信息是明文传输，HTTPS则是具有安全性的 SSL 加密传输协议
- HTTP的连接很简单，是无状态的，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全



## 2、http状态码有那些？分别代表是什么意思？

```javascript
100-199 用于指定客户端应相应的某些动作。 
200-299 用于表示请求成功。 
300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。 (304缓存)
400-499 用于指出客户端的错误。400    1、语义有误，当前请求无法被服务器理解。401   当前请求需要用户验证 403  服务器已经理解请求，但是拒绝执行它。 404地址错误
500-599 用于支持服务器错误。 503 – 服务不可用 500 服务器错误
```



## 3. HTTP状态码304是多好还是少好

服务器为了提高网站访问速度，对之前访问的部分页面指定缓存机制，当客户端在此对这些页面进行请求，服务器会根据缓存内容判断页面与之前是否相同，若相同便直接返回304，此时客户端调用缓存内容，不必进行二次下载。

状态码304不应该认为是一种错误，而是对客户端**有缓存情况下**服务端的一种响应。

搜索引擎蜘蛛会更加青睐内容源更新频繁的网站。通过特定时间内对网站抓取返回的状态码来调节对该网站的抓取频次。若网站在一定时间内一直处于304的状态，那么蜘蛛可能会降低对网站的抓取次数。相反，若网站变化的频率非常之快，每次抓取都能获取新内容，那么日积月累，的回访率也会提高。

**产生较多304状态码的原因：**

- 页面更新周期长或不更新
- 纯静态页面或强制生成静态html

**304状态码出现过多会造成以下问题：**

- 网站快照停止；
- 收录减少；
- 权重下降。





## 4、常见的HTTP请求头和响应头

**HTTP Request Header 常见的请求头：**

- Accept:浏览器能够处理的内容类型
- Accept-Charset:浏览器能够显示的字符集
- Accept-Encoding：浏览器能够处理的压缩编码
- Accept-Language：浏览器当前设置的语言
- Connection：浏览器与服务器之间连接的类型
- Cookie：当前页面设置的任何Cookie
- Host：发出请求的页面所在的域
- Referer：发出请求的页面的URL
- User-Agent：浏览器的用户代理字符串

**HTTP Responses Header 常见的响应头：**

- Date：表示消息发送的时间，时间的描述格式由rfc822定义
- server:服务器名称
- Connection：浏览器与服务器之间连接的类型
- Cache-Control：控制HTTP缓存
- content-type:表示后面的文档属于什么MIME类型

常见的 Content-Type 属性值有以下四种：

（1）application/x-www-form-urlencoded：浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1=val1&key2=val2 的方式进行编码，key 和 val 都进行了 URL转码。

（2）multipart/form-data：该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。

（3）application/json：服务器消息主体是序列化后的 JSON 字符串。

（4）text/xml：该种方式主要用来提交 XML 格式的数据。







## 5、HTTP请求报文的是什么样的？

请求报⽂有4部分组成:

- 请求⾏
- 请求头部
- 空⾏
- 请求体

![image.png](https://tva1.sinaimg.cn/large/e6c9d24ely1h659ijldrnj211k0dejsi.jpg) **其中：** （1）请求⾏包括：请求⽅法字段、URL字段、HTTP协议版本字段。它们⽤空格分隔。例如，GET /index.html HTTP/1.1。 （2）请求头部:请求头部由关键字/值对组成，每⾏⼀对，关键字和值⽤英⽂冒号“:”分隔

- User-Agent：产⽣请求的浏览器类型。
- Accept：客户端可识别的内容类型列表。
- Host：请求的主机名，允许多个域名同处⼀个IP地址，即虚拟主机。

（3）请求体: post put等请求携带的数据 ![image.png](https://tva1.sinaimg.cn/large/e6c9d24ely1h659iiuthmj212g0m2n0a.jpg)

## 6、 HTTP响应报文的是什么样的？

请求报⽂有4部分组成:

- 响应⾏
- 响应头
- 空⾏
- 响应体

![image.png](https://tva1.sinaimg.cn/large/e6c9d24ely1h659ikkhckj212c0kot9u.jpg)

- 响应⾏：由网络协议版本，状态码和状态码的原因短语组成，例如 HTTP/1.1 200 OK 。
- 响应头：响应部⾸组成
- 响应体：服务器响应的数据



## 7、GET方法URL长度限制的原因

实际上**HTTP协议规范并没有对get方法请求的url长度进行限制**，这个限制是特定的**浏览器及服务器对它的限制**。 IE对URL长度的限制是2083字节(2K+35)。由于IE浏览器对URL长度的允许值是最小的，所以开发过程中，**只要URL不超过2083字节，那么在所有浏览器中工作都不会有问题**。

```
GET的长度值 = URL（2083）- （你的Domain+Path）-2（2是get请求中?=两个字符的长度）
```

- Google (chrome)：URL最大长度限制为 8182 个字符。





## 8、 说说get和post的区别

* GET通过URL传输数据，而POST的数据通过请求消息体(body)传输

* 是安全且幂等的，POST是非安全非幂等的（幂等的意思就是不管发多少次请求，结果都一样）
* GET请求只发送一个包，POST请求需要发送两个以上的包（因为POST有请求消息体）
* GET用来获取数据，不需要每次都与数据库连接，所以可以使用缓存
  POST一般是操作过程，比如修改、删除等，所以必须和数据库交互，不能使用缓存
  用法：GET用来读取数据，POST用来写数据

```
补充：
GET传参长度的误区：我们经常说get请求参数的大小存在限制，而post请求的参数大小是无限制的，实际上是因为：
1.GET的最大长度显示是因为 浏览器和 web服务器限制了 URI的长度
2.不同的浏览器和WEB服务器，限制的最大长度不一样
```





## 9、面试官：如何实现jwt鉴权机制？说说你的思路

**概念：**

### **概念：**

在目前前后端分离的开发过程中，使用`token`鉴权机制用于身份验证是最常见的方案，流程如下：

- 服务器当验证用户账号和密码正确的时候，给用户颁发一个令牌，这个令牌作为后续用户访问一些接口的凭证
- 后续访问会根据这个令牌判断用户时候有权限进行访问

### **如何做：**

`Token`的使用分成了两部分：

- 生成token：登录成功的时候，颁发token
- 验证token：访问某些资源或者接口时，验证token

#### 生成 token

借助第三方库`jsonwebtoken`，通过`jsonwebtoken` 的 `signq` 签名方法生成一个 `token`：

- 第一个参数指的是 Payload
- 第二个是秘钥，服务端特有
- 第三个参数是 option，可以定义 token 过期时间

在前端接收到`token`后，一般情况会通过`localStorage`进行缓存，然后将`token`放到`HTTP`请求头`Authorization` 中

#### 验证：

后端拿到token后，在进行验证是否合法，验证就有访问权限，不通过可以给前端返回401，提示没有权限



## 10、浏览器渲染机制

1. 构建DOM树（parse）：渲染引擎解析HTML文档，首先将标签转换成DOM树中的DOM node
2. 构建渲染树（construct）：解析对应的CSS样式文件信息
3. 布局渲染树（reflow/layout）：从根节点递归调用，计算每一个元素的大小、位置等，给出每个节点所应该在屏幕上出现的精确坐标；
4. 绘制渲染树（paint/repaint）：遍历渲染树，使用UI后端层来绘制每个节点。

![img](https://tva1.sinaimg.cn/large/008vxvgGly1h7mb3l6hi9j30go07swf9.jpg)

## 11、重绘和重排（回流）的区别

当元素的样式发生变化时，浏览器需要触发更新，重新绘制元素。这个过程中，有两种类型的操作，即重绘与回流。

- **重绘(repaint)**: 当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要UI层面的重新像素绘制，因此 **损耗较少**
- 重排/回流(reflow)**: 当元素的尺寸、结构或触发某些属性时，浏览器会重新渲染页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。会触发回流的操作:
  - 页面初次渲染(**第一次也叫layout布局**)
  - 浏览器窗口大小改变
  - 元素尺寸、位置、内容发生改变
  - 元素字体大小变化
  - 添加或者删除可见的 dom 元素
  - 激活 CSS 伪类（例如：:hover）
  - 查询某些属性或调用某些方法
    - clientWidth、clientHeight、clientTop、clientLeft

**回流必定触发重绘，重绘不一定触发回流。重绘的开销较小，回流的代价较高。**

#### 最佳实践:

- css

  - 避免使用`table`布局
  - 将动画效果应用到`position`属性为`absolute`或`fixed`的元素上
  - transform

- javascript

  - 避免频繁操作样式，可汇总后统一 **一次修改**
  - 尽量使用`class`进行样式修改  setAttribute("class","box")
  - 减少`dom`的增删次数，可使用 **字符串** 或者 `documentFragment` 一次性插入
  - 极限优化时，修改样式可将其`display: none`后修改

  ```
  box.style.width = "100px";
  box.style.height = "200px";
  box.style.lineHeight = "200px";
  box.setAttribute("class","box")
  box.classList.add('box')
  
  div
  ```

## 12、web常见的攻击方式有哪些？如何防御？

##### XSS攻击：（Cross Site Scripting）跨域脚本攻击。 

原理： 不需要你做任何的登录认证，它会通过合法的操作（比如在 url 中输入、在评论框中输入）， 向你的页面注入脚本（可能是 js、hmtl 代码块等）。

 防范： 

1. 编码；对于用户输入进行编码 
2. 过滤；移除用户输入和事件相关的属性。(过滤 script、style、iframe等节点) 
3. 校正；使用 DOM Parse 转换，校正不配对的 DOM 标签 

#####  CSRF攻击：SRF（Cross-site request forgery）跨站请求伪造。 

原理： 

1. 登录受信任网站 A，并在本地生成 Cookie （如果用户没有登录网站 A，那么网站 B 在诱导的时候，请求网站 A 的 api 接口时，会提示你登录） 
2. 在不登出 A 的情况下，访问危险网站 B（其实是利用了网站 A 的漏洞） 防范： 1.  token 验证； 2.  隐藏令牌；把 token 隐藏在 http 请求的 head 中。 
3. referer 验证；验证页面来源。 

二者的区别：

1. CSRF：需要用户先登录网站 A，获取 cookie。    XSS：不需要登录。 
2. CSRF：是利用网站 A 本身的漏洞，去请求网站 A 的 api。    XSS：是向网站 A 注入 JS 代码，然后执行 JS 里的代码，篡改网站 A 的内容。



## 13、一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？

1.读取缓存,搜索自身的 DNS 缓存。(如果找到了就直接访问这个IP 地址)
2.DNS 解析:将域名解析成 IP 地址
3.建立TCP 连接,TCP三次握手  （TCP/IP）
4.发送 HTTP 请求报文
5.服务器处理请求并返回响应 HTTP 报文
6.浏览器解析渲染页面
7.断开连接：TCP 四次挥手

> 关于第六步浏览器解析渲染页面又可以聊聊如果返回的是html页面
> 根据 HTML 解析出 DOM 树
> 根据 CSS 解析生成 CSS 规则树
> 结合 DOM 树和 CSS 规则树，生成渲染树
> 根据渲染树计算每一个节点的信息
> 根据计算好的信息绘制页面



> 简易描述三次握手
>
> 客户端：服务端你在么？ 
> 服务端：客户端我在，你要连接我么？ 
> 客户端：是的服务端，我要链接。 
> 连接打通，可以开始请求来





## 14、前端对后端返回的数据如何处理？

一般来说，后端会返回json格式或者xml格式的数据。
如果是json格式的话，使用**JSON.parse(后端返回的json字符串);**转成对象

> 如果要把对象在格式化成字符串的haul，使用  **JSON.stringify(对象)**

如果是XML格式的话，那就先使用 xml2json转化为JSON格式，然后在按照JSON格式进行处理。



## 15、请你谈谈Cookie的弊端？

缺点：

1.Cookie数量和长度的限制。每个域下最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉。

2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目的了。

3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。

## 16、请描述一下cookies，sessionStorage和localStorage的区别？

 localStorage  长期存储数据，浏览器关闭后数据不丢失；

 sessionStorage 数据在浏览器关闭后自动删除。 

 cookie数据始终在同源的http请求中携带（即使不需要）

